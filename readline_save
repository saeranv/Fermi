ax.set_zlim(-1.01, 1.01)
ax.zaxis.set_major_locator(LinearLocator(10))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))
# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=5)
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-3.0, 3.0, 0.05)
X, Y = np.meshgrid(x, y)
zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-3.0, 3.0, 0.005)
X, Y = np.meshgrid(x, y)
zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-3.0, 3.0, 0.5)
X, Y = np.meshgrid(x, y)
zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
zs = np.array([fun(x,y) for x,y in zip(np.ravel(X), np.ravel(Y))])
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
zs = np.array()
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    zs.append(fun(x,y))
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    L.append(fun(x,y))
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
def fun(x, y):
  return x**2 + y
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    L.append(fun(x_,y_))
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import random
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = x_**2 + y_
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = x_**2 + y_
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import math
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_)
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import math
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.1)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import math
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_*0.5)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_*0.05)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    z_ *= 0.05
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    z_ -= 0.02
    L.append(z_)
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
print z_
print L
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
"""
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
print L
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
"""
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#natural log
y1 = map(lambda x_: math.ln(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
"""
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
print L
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
"""
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#natural log
y1 = map(lambda x_: math.log(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
"""
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
print L
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
"""
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(1,50,1)
#natural log
y1 = map(lambda x_: math.log(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
"""
# -------------------------------------------------------------------------
# 3D Mesh
# -------------------------------------------------------------------------
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x = y = np.arange(-5.0, 5.0, 0.05)
X, Y = np.meshgrid(x, y)
L = []
for x_,y_ in  zip(np.ravel(X), np.ravel(Y)):
    z_ = math.sin(x_) + math.sin(y_)
    L.append(z_)
print L
zs = np.array(L)
Z = zs.reshape(X.shape)
ax.plot_surface(X, Y, Z)
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.show()
"""
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic
def f(x__): return x__
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic
def f(x__): return math.log(2)
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic
def f(x__): return math.log(x__)
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,2)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 2)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 0.2)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 0.5)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 0.2)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 0.1)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
y1 = map(lambda x_: f(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return K_ * (1 - (x__/K_))
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,y,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return K_ * (1 - (x__/K_))
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,y,'k')
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(0,50,0.5)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return K_ * (1 - (x__/K_))
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return K_ * (1 - (x__/K_))
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return K_ * (1 - (x__/K_))
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,p_exp)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(x__,K_):
    return 1 - (x__/K_)
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(x_,K), p_exp)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(p__,K_):
    return 1 - (p__/K_)
p_exp = map(lambda x_: f(x_), x)
y = map(lambda p_: f2(p_,K), p_exp)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plast,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp, x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
from matplotlib.pyplot import *
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
from ForwardEuler_func2 import Fowrard Euler
u,t = ForwardEuler(r, U0=0.1, T=40, n=400)
plot(t,u)
show()
"""
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
"""
%matplotlib inline
from matplotlib.pyplot import *
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
from ForwardEuler_func2 import Forward Euler
u,t = ForwardEuler(r, U0=0.1, T=40, n=400)
plot(t,u)
show()
"""
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
"""
%matplotlib inline
from matplotlib.pyplot import *
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
from ForwardEuler_func2 import ForwardEuler
u,t = ForwardEuler(r, U0=0.1, T=40, n=400)
plot(t,u)
show()
"""
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
"""
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, U0=0.1, T=40, n=400)
plot(t,u)
show()
"""
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
"""
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
"""
x = np.arange(-50,50,1)
#logistic differential equation
K = 100.0 # carrying capactiy
def f(x__):
    P = math.pow(math.e,x__ * 0.15)
    return P
def f2(plst,xlst):
    L = []
    for p_,x_ in zip(plst,xlst):
        P = p_ * (1 - p_/K)
        L.append(P)
    return L
p_exp = map(lambda x_: f(x_), x)
y = f2(p_exp,x)
plt.plot(x,y)
#plot graphics
#plt.axis([-5,20,0,10])
plt.show()
"""
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
R = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        print k
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
print type(k)
print k
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        print k
        #t[k+1] = t[k] + dt
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        #t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/R)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        f(u[k],t[k])
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        f(u[k],t[k])
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k]
        t[k]
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1- u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        uk,tk = u[k], t[k]
        f(uk,tk)
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1 - u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        uk,tk = u[k], t[k]
        s = f(uk,tk)
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def f(u,t):
    return alpha * u *(1 - u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        uk,tk = u[k], t[k]
        f(uk,tk)
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def fx(u,t):
    return alpha * u *(1 - u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        uk,tk = u[k], t[k]
        fx(uk,tk)
        #u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def fx(u,t):
    return alpha * u *(1 - u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*f(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
from matplotlib.pyplot import *
import numpy as np
import math
# -------------------------------------------------------------------------
# Logistic growth
# -------------------------------------------------------------------------
alpha = 0.2
r = 1.0
def fx(u,t):
    return alpha * u *(1 - u/r)
def ForwardEuler(f, U0, T, n):
    """Solve u'=f(u,t), u(0)=U0, with n steps until t=T."""
    t = np.zeros(n+1)
    u = np.zeros(n+1)  # u[k] is the solution at time t[k]
    u[0] = U0
    t[0] = 0
    dt = T/float(n)
    for k in range(n):
        t[k+1] = t[k] + dt
        u[k+1] = u[k] + dt*fx(u[k], t[k])
    return u, t
u,t = ForwardEuler(r, 0.1, 40, 400)
plot(t,u)
show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
"""
character description
'-'       solid line style
'--'      dashed line style
'-.'      dash-dot line style
':'       dotted line style
'.'       point marker
','       pixel marker
'o'       circle marker
'v'       triangle_down marker
'^'       triangle_up marker
'<'       triangle_left marker
'>'       triangle_right marker
'1'       tri_down marker
'2'       tri_up marker
'3'       tri_left marker
'4'       tri_right marker
's'       square marker
'p'       pentagon marker
'*'       star marker
'h'       hexagon1 marker
'H'       hexagon2 marker
'+'       plus marker
'x'       x marker
'D'       diamond marker
'd'       thin_diamond marker
'|'       vline marker
'_'       hline marker
"""
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Power law Relationship: change the x^2
# -------------------------------------------------------------------------
x = np.arange(0,50,1)
#up opening parabola
y1 = map(lambda x_: math.pow(x_,2), x)
plt.plot(x,y1,'k')
#side opening parabola
y2 = map(lambda x_: math.pow(x_,0.5), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
# -------------------------------------------------------------------------
# Natural log Relationship:
# -------------------------------------------------------------------------
x = np.arange(1,50,1)
#natural log
y1 = map(lambda x_: math.log(x_), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
import fermiplot
import math
"""Newton's Law of Cooling
Represents a boiling cup of water cooling to room T
Ta = 25 C
Ti @ 0m is 100 C
Ti @ 30m is 50 C
    dy/dt = ky
    y = Ti - Ta
so...
    Ti = y + Ta
    dT/dt = dy/dt = dTa
          = dy/dt
    dT/dt = dy/dt
now let's solve:
    ky = Ti - Ta
and...
    ky = C * e^kt
so...
    C * e^kt = Ti - Ta
    Ti = C * e^kt - Ta
    log((Ti-Ta)/C) = log(e^kt)
sub in values from measured decay
    k = -0.0462
Therefore:
    Ti = 100 * e^(-0.0462 * t)
"""
fx1 = lambda x: 25 + (100 * math.pow(math.e, x* -0.0462)) # Ti
fx2 = lambda x: 25 # room ambient Ta
fermiplot.plot([fx1,fx2],0,100,0,100)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    #fx_lst = [fx_1,fx_2]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(a,b: a+b, fx_lst)
    #fx_lst = [fx_1,fx_2]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    #fx_lst = [fx_1,fx_2]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(xlst,fxlst,'k'+color_lst[i%len(color_lst)])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(x_lst,fx_lst,'k'+color_lst[i%len(color_lst)])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(x_lst,fx_lst,'k'+color_lst[int(i%len(color_lst)]))
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(x_lst,fx_lst,'k'+color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = -10,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,-10,20
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    fx_lst = reduce(lambda a,b: a+b, fx_lst)
    x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    for i in fx_lst:
        print i
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    k_lst = np.arange(0,1,1/float(len(x_lst)))
    fx_lst = map(lambda k:map(lambda x: math.pow(math.e,k*x),x_lst),k_lst)
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    #plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    #plt.axis([x1,x2,y1,y2])
    #plt.grid()
    #plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = float(len(x_lst))
    k_lst = np.arange(0,1,1/fxlstlen)
    fx_lst = [None] * fxlstlen
    for ki in xrange(int(fxlstlen)):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst(lambda proxy: math.pow(math.e,k*proxy))
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    #plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    #plt.axis([x1,x2,y1,y2])
    #plt.grid()
    #plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = float(len(x_lst))
    k_lst = np.arange(0,1,1/fxlstlen)
    fx_lst = [None] * fxlstlen
    for ki in xrange(int(fxlstlen)):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    #plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    #plt.axis([x1,x2,y1,y2])
    #plt.grid()
    #plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen)
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    #plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    #plt.axis([x1,x2,y1,y2])
    #plt.grid()
    #plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    #plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    #plt.axis([x1,x2,y1,y2])
    #plt.grid()
    #plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    for i in fx_lst:
        print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,color_lst[i%len(color_lst)])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)
        print lin
        plt.plot(xlst,ylst,lin])
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    plt.plot(x_lst,fx_lst,color_lst[int(i%len(color_lst))])
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    lin = color_lst[i%len(color_lst)]
    print lin
    plt.plot(x_lst,fx_lst,lin)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst.append((lambda proxy: math.pow(math.e,k*proxy)))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy))
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #for xi in xrange(x_lst):
        #    x = x_lst[xi]
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,20./float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,20,20/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*10*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*10*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,100,-10,100
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*0.5*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,-10,10
    x_lst = np.arange(x1,x2,1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*0.5*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,3,0,3
    x_lst = np.arange(x1,x2,0.1)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*0.5*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,3,0,3
    x_lst = np.arange(x1,x2,0.001)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*0.5*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,3,0,3
    x_lst = np.arange(x1,x2,0.01)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        lin = color_lst[i%len(color_lst)]
        print lin
        plt.plot(xlst,ylst,lin)
        print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,30,0,30
    x_lst = np.arange(x1,x2,0.01)
    fxlstlen = len(x_lst)
    k_lst = np.arange(0,1,1/float(fxlstlen))
    fx_lst = [None] * fxlstlen
    for ki in xrange(fxlstlen):
        k = k_lst[ki]
        #print k
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    #for i in fx_lst:
    #    print i
    #x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
    for i in xrange(len(fx_lst)):
        fx = fx_lst[i]
        ylst = map(lambda x: fx(x), x_lst)
        lin = color_lst[i%len(color_lst)]
        plt.plot(x_lst,ylst,lin)
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
    #fx_lst = [fx_1,fx_2]
    #plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
x1,x2,y1,y2 = 0,30,0,30
x_lst = np.arange(x1,x2,0.01)
fxlstlen = len(x_lst)
k_lst = np.arange(0,1,1/float(fxlstlen))
fx_lst = [None] * fxlstlen
for ki in xrange(fxlstlen):
    k = k_lst[ki]
    #print k
    fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
#for i in fx_lst:
#    print i
#x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda x: fx(x), x_lst)
    lin = color_lst[i%len(color_lst)]
    plt.plot(x_lst,ylst,lin)
    #print 'fx {}'.format(i)
    #xy_matrix(xlst,ylst)
plt.axis([x1,x2,y1,y2])
plt.grid()
plt.show()
#fx_lst = [fx_1,fx_2]
#plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
x1,x2,y1,y2 = 0,30,0,30
x_lst = np.arange(x1,x2,0.1)
fxlstlen = len(x_lst)
k_lst = np.arange(0,1,1/float(fxlstlen))
fx_lst = [None] * fxlstlen
for ki in xrange(fxlstlen):
    k = k_lst[ki]
    #print k
    fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
#for i in fx_lst:
#    print i
#x_lst = np.arange(x1,x2,(x2-x1)/float(len(fx_lst)))
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda x: fx(x), x_lst)
    lin = color_lst[i%len(color_lst)]
    plt.plot(x_lst,ylst,lin)
    #print 'fx {}'.format(i)
    #xy_matrix(xlst,ylst)
plt.axis([x1,x2,y1,y2])
plt.grid()
plt.show()
#fx_lst = [fx_1,fx_2]
#plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    print 'Remember: if use log make sure to change x constraints'
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 20
    for ki in xrange(20):
        k = k_lst[ki]
        fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    plot(fx_lst,x1=0,x2=20,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    print 'Remember: if use log make sure to change x constraints'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst = [fx_1,fx_2]
    #fx_lst = [None] * 20
    #for ki in xrange(20):
    #    k = k_lst[ki]
    #    fx_lst[ki] = lambda proxy: math.pow(math.e,k*proxy)
    plot(fx_lst,x1=0,x2=20,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 20
    for k in range(20):
        fx_lst[k] = lambda x: math.pow(math.e,k/20.*x)
    plot(fx_lst,x1=0,x2=20,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 20
    for k in range(20):
        print k/20.
        fx_lst[k] = lambda x: math.pow(math.e,k/20.*x)
    plot(fx_lst,x1=0,x2=20,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 10
    for k in range(0):
        print k/10.
        fx_lst[k] = lambda x: math.pow(math.e,k/20.*x)
    plot(fx_lst,x1=0,x2=10,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 10
    for k in range(0):
        print k/10.
        fx_lst[k] = lambda x: math.pow(math.e,k/10.*x)
    plot(fx_lst,x1=0,x2=10,y2=50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 10
    for k in range(0):
        print k/10.
        fx_lst[k] = lambda x: math.pow(math.e,k/10.*x)
    plot(fx_lst,0,10,0,50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    fx_lst = [None] * 10
    for k in range(10):
        print k/10.
        fx_lst[k] = lambda x: math.pow(math.e,k/10.*x)
    plot(fx_lst,0,10,0,50)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,10,0,20
    xlen = x2-x1
    fx_lst = [None] * x2-x1
    for k in range(x2-x1):
        print k/float(xlen)
        fx_lst[k] = lambda x: math.pow(math.e,k/float(xlen)*x)
    plot(fx_lst,0,10,0,20)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,10,0,20
    xlen = x2-x1
    fx_lst = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        fx_lst[k] = lambda x: math.pow(math.e,k/float(xlen)*x)
    plot(fx_lst,0,10,0,20)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,10,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k/float(xlen)*x))
    plot(fx_lst,0,10,0,20)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,10,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k/float(xlen)*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    #xlen = x2-x1
    #fx_lst = []# = [None] * int(x2-x1)
    #for k in range(x2-x1):
    #    print k/float(xlen)
    #    k = k/float(xlen)
    #    fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k']#+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k'])#+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst = [fx_1,fx_2]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    print x2-x1
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.3,0,75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    x1,x2,y1,y2 = 0,20,0,20
    """
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    print x2-x1
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    """
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    x1,x2,y1,y2 = 0,20,0,20
    """
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    print x2-x1
    for k in range(x2-x1):
        print k/float(xlen)
        k = k/float(xlen)
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    """
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    x1,x2,y1,y2 = 0,20,0,20
    xlen = x2-x1
    fx_lst = []# = [None] * int(x2-x1)
    print x2-x1
    for k in range(4):
        print k/4.
        k = k/4.
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []# = [None] * int(x2-x1)
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda x: math.pow(math.e,k*x))
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst = [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst = [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,2,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        k = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,k*xin))
    print type(fx_lst)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
print type(fx_lst)
print type(fx_lst[0])
print type(fx_lst)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,4,1):
        print k/4.
        frac = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,5,1):
        print k/4.
        frac = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,1,1):
        print k/4.
        frac = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,2,1):
        print k/4.
        frac = k/4.
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,2,1):
        print k/4.
        frac = k/8.
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,2,1):
        frac = k/8.
        print frac
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fxlst,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fxlst) != type([]):
        fxlst = [fxlst]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fxlst)):
        fx = fxlst[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        print frac
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        print frac
        fx_lst.append(lambda xin: math.pow(math.e,frac*xin))
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        print frac
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda x: fx(x), xlst)
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        print frac
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda x: fx(x), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,20,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda x: fx(x), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,3,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,4,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,4,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_3 = lambda x: math.pow(math.e,0.75*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,4,1):
        frac = k/8.
        func = lambda xin: math.pow(math.e,frac*xin)
        fx_lst.append(func)
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    #for k in range(1,4,1):
    #    frac = k/8.
    #    func = lambda xin: math.pow(math.e, frac * xin)
    #    fx_lst.append(func)
    fx_lst = [lambda x: x*x for x in range(10)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    #for k in range(1,4,1):
    #    frac = k/8.
    #    func = lambda xin: math.pow(math.e, frac * xin)
    #    fx_lst.append(func)
    fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(10)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    #for k in range(1,4,1):
    frac = 1/8.
    #    func = lambda xin: math.pow(math.e, frac * xin)
    #    fx_lst.append(func)
    fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,4,1):
        frac = 1/8.
        func = lambda xin: math.pow(math.e, frac * xin)
        fx_lst.append(func)
    #
    fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,4,1):
        frac = 1/8.
        func = lambda xin: math.pow(math.e, frac * xin)
        fx_lst.append(func)
    #fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,40,1):
        frac = 1/8.
        func = lambda xin: math.pow(math.e, frac * xin)
        fx_lst.append(func)
    #fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.25*x)
    fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    for k in range(1,40,1):
        frac = 1/8.
        func = lambda xin: math.pow(math.e, frac * xin)
        fx_lst.append(func)
    #fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
""" Fermi Plots!
Args:
    fx:    # list of function arguments
    x1:    # start domain
    x2:    # end domain
    y1:    # start range
    y2:    # end range
Returns:
    A matplotlib.pyplot
How to add this to systems path
import sys
sys.path.append("..")
"""
import matplotlib.pyplot as plt
import numpy as np
import math
color_lst = ['b','g','r','c','m','y','k','w']
style_lst = [
'-','--','-.',':','.',',',
'o','v','^','<','>','1','2',
'3','4','s','p','*','h','H',
'+','x','D','d','|','_'
]
def xy_matrix(xlst_,ylst_):
    matrix = [xlst_,ylst_]
    transposed_matrix = zip(*matrix) # transpose matrix
    #for xy in transposed_matrix:
    #    print xy
    #print '--0.5'
def plot(fx_lst_,x1=-10,x2=10,y1=-5,y2=10.0):
    xlst = np.arange(x1,x2+1,1)
    if type(fx_lst_) != type([]):
        fx_lst_ = [fx_lst_]
    # define the axis
    x_axis_lst = map(lambda x: 0, xlst)
    plt.plot(xlst,x_axis_lst,'r-')
    plt.plot([0]*len(xlst),xlst,'r-')
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        print ylst
        plt.plot(xlst,ylst,'k')#+style_lst[i])
        #print 'fx {}'.format(i)
        #xy_matrix(xlst,ylst)
    plt.axis([x1,x2,y1,y2])
    plt.grid()
    plt.show()
if __name__ == "__main__":
    x1,x2,y1,y2 = 0,10,0,20
    fx_lst = []
    #for k in range(1,40,1):
    #    frac = 1/8.
    #    func = lambda xin: math.pow(math.e, frac * xin)
    #    fx_lst.append(func)
    fx_lst = [lambda x: math.pow(math.e, frac * x) for x in range(100)]
    for i in fx_lst:
        for j in range(10):
            print i(j)
        print 'end'
    #fx_1 = lambda x: math.pow(math.e,0.5*x)
    #fx_2 = lambda x: math.pow(math.e,0.25*x)
    #fx_lst += [fx_1,fx_2,fx_3]
    plot(fx_lst,x1,x2,y1,y2)
import matplotlib.pyplot as plt
import numpy as np
import math
def plot(fx_lst_):
    xlst = np.arange(x1,x2+1,1)
    for i in xrange(len(fx_lst_)):
        fx = fx_lst_[i]
        ylst = map(lambda xin_: fx(xin_), xlst)
        plt.plot(xlst,ylst,'k'+style_lst[i%len(style_lst)])
    plt.show()
if __name__ == "__main__":
    fx_lst = []
    for k in range(2,4,1):
        print 1/float(k)
        func = lambda x_: math.pow(math.e, 1/float(k) * x_)
        fx_lst.append(func)
    fx_1 = lambda x: math.pow(math.e,0.5*x)
    fx_2 = lambda x: math.pow(math.e,0.33*x)
    fx_lst += [fx_1,fx_2]
    plot(fx_lst)
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
#fx_1 = lambda x: math.pow(math.e,0.5*x)
#fx_2 = lambda x: math.pow(math.e,0.33*x)
#fx_lst += [fx_1,fx_2]
xlst = range(1,10,1
for i in xrange(len(fx_lst)):
    fx = fx_lst_[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print ylst
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
#fx_1 = lambda x: math.pow(math.e,0.5*x)
#fx_2 = lambda x: math.pow(math.e,0.33*x)
#fx_lst += [fx_1,fx_2]
xlst = range(1,10,1
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print ylst
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
#fx_1 = lambda x: math.pow(math.e,0.5*x)
#fx_2 = lambda x: math.pow(math.e,0.33*x)
#fx_lst += [fx_1,fx_2]
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print ylst
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
#fx_1 = lambda x: math.pow(math.e,0.5*x)
#fx_2 = lambda x: math.pow(math.e,0.33*x)
#fx_lst += [fx_1,fx_2]
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
fx_1 = lambda x: math.pow(math.e,0.5*x)
fx_2 = lambda x: math.pow(math.e,0.33*x)
fx_lst += [fx_1,fx_2]
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(math.e, 1/float(k) * x_)
    fx_lst.append(func)
fx_1 = lambda x: math.pow(math.e,0.5*x)
fx_2 = lambda x: math.pow(math.e,0.33*x)
fx_lst = [fx_1,fx_2]
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
https://stackoverflow.com/questions/31340781/list-argument-for-a-lambda-function-in-python
https://stackoverflow.com/questions/36181317/python-specify-lambda-arguments-as-a-function-argument
https://stackoverflow.com/questions/24403774/pass-list-as-one-of-functions-arguments
What you've done there is create a function object which references a variable,
it does not create its own copy, so that when you go to execute that function,
it looks up the variable, which now has the last value from the loop.
@Holt closure is probably the safest way to a accomplish the task, albeit a bit
more convoluted. I would change the name of my variable within the closure to
make it clearer what is happening.
What this does is create a separate scope, so that once execution leaves the
outer lambda function (having called it and returned a value which is the function
object you actually want) the count variable in your function object and the count
variable in your loop no longer reference the same place in memory, and you can
increment the counter without affecting the variable referenced by the function.
"""
fx_lst = []
for k in range(2,4,1):
    print 1/float(k)
    func = lambda x_: math.pow(float(k) * x_)
    fx_lst.append(func)
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
https://stackoverflow.com/questions/31340781/list-argument-for-a-lambda-function-in-python
https://stackoverflow.com/questions/36181317/python-specify-lambda-arguments-as-a-function-argument
https://stackoverflow.com/questions/24403774/pass-list-as-one-of-functions-arguments
What you've done there is create a function object which references a variable,
it does not create its own copy, so that when you go to execute that function,
it looks up the variable, which now has the last value from the loop.
@Holt closure is probably the safest way to a accomplish the task, albeit a bit
more convoluted. I would change the name of my variable within the closure to
make it clearer what is happening.
What this does is create a separate scope, so that once execution leaves the
outer lambda function (having called it and returned a value which is the function
object you actually want) the count variable in your function object and the count
variable in your loop no longer reference the same place in memory, and you can
increment the counter without affecting the variable referenced by the function.
"""
fx_lst = []
for k in range(1,3,1):
    print 1/float(k)
    func = lambda x_: math.pow(float(k) * x_)
    fx_lst.append(func)
xlst = range(1,10,1)
for i in xrange(len(fx_lst)):
    fx = fx_lst[i]
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
https://stackoverflow.com/questions/31340781/list-argument-for-a-lambda-function-in-python
https://stackoverflow.com/questions/36181317/python-specify-lambda-arguments-as-a-function-argument
https://stackoverflow.com/questions/24403774/pass-list-as-one-of-functions-arguments
What you've done there is create a function object which references a variable,
it does not create its own copy, so that when you go to execute that function,
it looks up the variable, which now has the last value from the loop.
@Holt closure is probably the safest way to a accomplish the task, albeit a bit
more convoluted. I would change the name of my variable within the closure to
make it clearer what is happening.
What this does is create a separate scope, so that once execution leaves the
outer lambda function (having called it and returned a value which is the function
object you actually want) the count variable in your function object and the count
variable in your loop no longer reference the same place in memory, and you can
increment the counter without affecting the variable referenced by the function.
"""
fx_lst = []
for k in range(1,3,1):
    print 1/float(k)
    func = lambda x_: math.pow(float(k) * x_)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
https://stackoverflow.com/questions/31340781/list-argument-for-a-lambda-function-in-python
https://stackoverflow.com/questions/36181317/python-specify-lambda-arguments-as-a-function-argument
https://stackoverflow.com/questions/24403774/pass-list-as-one-of-functions-arguments
What you've done there is create a function object which references a variable,
it does not create its own copy, so that when you go to execute that function,
it looks up the variable, which now has the last value from the loop.
@Holt closure is probably the safest way to a accomplish the task, albeit a bit
more convoluted. I would change the name of my variable within the closure to
make it clearer what is happening.
What this does is create a separate scope, so that once execution leaves the
outer lambda function (having called it and returned a value which is the function
object you actually want) the count variable in your function object and the count
variable in your loop no longer reference the same place in memory, and you can
increment the counter without affecting the variable referenced by the function.
"""
fx_lst = []
for k in range(1,3,1):
    print 1/float(k)
    func = lambda x_: float(k) * x_
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
https://stackoverflow.com/questions/31340781/list-argument-for-a-lambda-function-in-python
https://stackoverflow.com/questions/36181317/python-specify-lambda-arguments-as-a-function-argument
https://stackoverflow.com/questions/24403774/pass-list-as-one-of-functions-arguments
What you've done there is create a function object which references a variable,
it does not create its own copy, so that when you go to execute that function,
it looks up the variable, which now has the last value from the loop.
@Holt closure is probably the safest way to a accomplish the task, albeit a bit
more convoluted. I would change the name of my variable within the closure to
make it clearer what is happening.
What this does is create a separate scope, so that once execution leaves the
outer lambda function (having called it and returned a value which is the function
object you actually want) the count variable in your function object and the count
variable in your loop no longer reference the same place in memory, and you can
increment the counter without affecting the variable referenced by the function.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = lambda x_: k * x_
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
Q
https://stackoverflow.com/questions/46029578/list-of-lambda-functions-in-python-applies-lambda-to-final-value-of-iterator
4
down vote
accept
What's happening is that your lambdas are being bound to the loop variable k rather than the value associated with it, that's all it is. The loop variable k persists even after the loop, and so those lambdas have access to it.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = (lambda x_: k * x_)(k)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = map(lambda xin_: fx(xin_), xlst)
    print i, ylst
import math
"""
Q
https://stackoverflow.com/questions/46029578/list-of-lambda-functions-in-python-applies-lambda-to-final-value-of-iterator
4
down vote
accept
What's happening is that your lambdas are being bound to the loop variable k rather than the value associated with it, that's all it is. The loop variable k persists even after the loop, and so those lambdas have access to it.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = (lambda x_: k * x_)(k)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = []
    for xin_ in xlst:
        ylst.append(fx(xin_))
    print i, ylst
import math
"""
Q
https://stackoverflow.com/questions/46029578/list-of-lambda-functions-in-python-applies-lambda-to-final-value-of-iterator
4
down vote
accept
What's happening is that your lambdas are being bound to the loop variable k rather than the value associated with it, that's all it is. The loop variable k persists even after the loop, and so those lambdas have access to it.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = (lambda k=k: lamba x_: k * x_)(k)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = []
    for xin_ in xlst:
        ylst.append(fx(xin_))
    print i, ylst
import math
"""
Q
https://stackoverflow.com/questions/46029578/list-of-lambda-functions-in-python-applies-lambda-to-final-value-of-iterator
4
down vote
accept
What's happening is that your lambdas are being bound to the loop variable k rather than the value associated with it, that's all it is. The loop variable k persists even after the loop, and so those lambdas have access to it.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = (lambda k=k: lambda x_: k * x_)(k)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = []
    for xin_ in xlst:
        ylst.append(fx(xin_))
    print i, ylst
import math
"""
Q
https://stackoverflow.com/questions/46029578/list-of-lambda-functions-in-python-applies-lambda-to-final-value-of-iterator
4
down vote
accept
What's happening is that your lambdas are being bound to the loop variable k rather than the value associated with it, that's all it is. The loop variable k persists even after the loop, and so those lambdas have access to it.
"""
fx_lst = []
for k in range(1,3,1):
    print k
    func = (lambda k=k: lambda x_: k * x_)(k)
    fx_lst.append(func)
xlst = range(1,10,1)
for fx in fx_lst:
    ylst = []
    for xin_ in xlst:
        ylst.append(fx(xin_))
    print ylst
print 'Q1 = ', 3.14/3. # 1.04
print 2*3.14 #= 6.3 rad
print 6.28/0.1
print 360/62.8
print 360/62.8 # = 5.28
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = ', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = '
print 2*3.14 #= 6.28 rad
print 6.28/0.1 #=62.8
print '= ', 360/62.8 # = 5.73 deg
#3.  =
#    sin40/A = sin90/10
#    A = 10*sin40/sin90 ~ 6.42
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = ', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = '
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
#3.  =
#    sin40/A = sin90/10
#    A = 10*sin40/sin90 ~ 6.42
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = ', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = ...'
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
#3.  =
#    sin40/A = sin90/10
#    A = 10*sin40/sin90 ~ 6.42
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = \t', 3.14/3. # 1.04
# 2.  0.1 rad
print '\tQ2 = ...'
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
#3.  =
#    sin40/A = sin90/10
#    A = 10*sin40/sin90 ~ 6.42
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = \t', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = \t...'
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
#3.  =
#    sin40/A = sin90/10
#    A = 10*sin40/sin90 ~ 6.42
print math.sin(math.pi/2.) * 10.0
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = \t', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = \t...'
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
# 3. O/H = sin(pi/2)
#    O = sin(pi/2) * H
print 'Q3 = \t...' 
print math.sin(math.pi/2.) * 10.0
print '\t', 2*math.pi / 9.0
print math.sin(theta) * 10.0
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output
import math
# Apollo Acceleration
# How to compute acceleration needs to create free return trajectory?
# Quiz 1
# When simulate trajectory of Apollo around moon imp?
# Mass of spacecraft: Not at all #b/c even if increase follow same trajectory
# Size of moon: Somewhat (don't want to hit)
# Motion of moon: Vital - make sure moon doesn't hit
# Size of the earth: Vital
# Motion of the earth: Somewhat.
# 3D: Somwhat, is in plane.
# Quiz 2
# Radians: 6.28 = 2pi = circumference of circle (derive from there)
# 1. 60 deg = 2pi/6 = pi/3 ~
print 'Q1 = \t', 3.14/3. # 1.04
# 2.  0.1 rad
print 'Q2 = \t...'
print '\t', 2*3.14 #= 6.28 rad
print '\t', 6.28/0.1 #=62.8
print '\t= ', 360/62.8 # = 5.73 deg
# 3. O/H = sin(pi/2)
#    O = sin(pi/2) * H
print 'Q3 = \t...' 
#6.28
theta = 2*math.pi / 9.0
print math.sin(theta) * 10.0
import pytest
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#natural growth y=ekt
y2 = map(lambda x_: math.pow(math.e,x_), x)
plt.plot(x,y2,'k:')
#plot graphics
plt.axis([-5,20,0,10])
plt.show()
%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from IPython.display import clear_output
from mpl_toolkits.mplot3d import Axes3D
import math
# Ref: http://www2.phy.ilstu.edu/~wenning/slh/Common%20Graph%20Forms.pdf
#Define graph constants
plt.xlabel('X')
plt.ylabel('Y')
plt.title("X vs Y")
plt.grid()
# -------------------------------------------------------------------------
# Exponential Relationship: change the 2^x
# -------------------------------------------------------------------------
x = np.arange(-50,50,1)
#natural decay y=e-kt
y1 = map(lambda x_: math.pow(math.e,x_*-1), x)
plt.plot(x,y1,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2)
xlst = np.arange(-100,100,1)
r = 50
ylst = map(lambda x: r*r - x*x, xlst)
plt.plot(x,ylst,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2)
xlst = np.arange(-100,100,1)
r = 50
ylst = map(lambda x: r*r - x*x, xlst)
plt.plot(xlst,ylst,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2)
xlst = np.arange(-100,100,1)
r = 5
ylst = map(lambda x: math.pow(r*r - x*x,.5), xlst)
plt.plot(xlst,ylst,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2)
xlst = np.arange(-100,100,1)
r = 5
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2)
xlst = np.arange(-100,100,1)
r = 50
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = 1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print d*.5/r
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print d*.5/r
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 5.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print d*.5/r
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print d*.5/r
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d*.5/r
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 10.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 1.
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 500
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50
p = .1
xlst = np.arange(-100,100,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50
p = .1
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50
p = .001
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50
p = .1
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .1
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-100,100,-100,100])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .1
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .01
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .1
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .0001
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 100
p = .01
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-2*r,2*r,p)
ylst = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst[i+1]  - ylst[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r+1,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r+p,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/(r*2)
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r+p,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d*2/r
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r+p,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d
print 'pi?', d/r
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = .5
p = .01
xlst = np.arange(-r,r+p,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d*2
print 'pi?', d/r
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import math
# find pi = 2*pi*r / 2*r # perimeter:diameter ratio
# r = sqrt(x2 + y2) # distance between n-dim pts
r = 50.
p = .01
xlst = np.arange(-r,r+p,p)
ylst1 = map(lambda x: math.pow(abs(r*r - x*x),.5), xlst)
ylst2 = map(lambda x: -1*math.pow(abs(r*r - x*x),.5), xlst)
plt.plot(xlst,ylst1,'k')
plt.plot(xlst,ylst2,'k')
# get the integral
d = 0
for i in xrange(len(xlst)-1):
    x_ = xlst[i+1] - xlst[i]
    y_ = ylst1[i+1]  - ylst1[i]
    d += math.pow(x_*x_ + y_*y_,.5)
print 'perimter actual: ', 2 * math.pi * r
print 'perimter calc: ', d*2
print 'pi?', d/r
#plot graphics
plt.axis([-2*r,2*r,-2*r,2*r])
plt.show()
if __name__ ==
#%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import math
"""
PROBLEM 1
Modify the orbit function below to model
one revolution of the moon aroudn the eart
assuming orbit is circular.
Use math.cos(angle) and math.sin(angle)
in radians.
"""
MOON_DISTANCE = 386e6 # radius
def orbit():
    num_steps = 50.
    moon_matrix = np.zeros([num_steps + 1, 2]) #2 x 51 matrix for x,y coordinates
    theta_inc = 2*math.pi/num_steps
    for i in xrange(len(moon_matrix)):
        theta = theta_inc * i
        moon_matrix[i][0] = MOON_DISTANCE * math.cos(theta)
        moon_matrix[i][1] = MOON_DISTANCE * math.sin(theta)
    #print moon_matrix
    return moon_matrix
def plot(mm):
    plt.axis('equal')
    plt.plot(map(lambda m:m[0],mm),map(lambda m: m[1],mm))
    
if __name__ == "__main__":
    mm = orbit()
    plot(mm)
#%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import math
"""
PROBLEM 1
Modify the orbit function below to model
one revolution of the moon aroudn the eart
assuming orbit is circular.
Use math.cos(angle) and math.sin(angle)
in radians.
"""
MOON_DISTANCE = 386e6 # radius
def orbit():
    num_steps = 50.
    moon_matrix = np.zeros([num_steps + 1, 2]) #2 x 51 matrix for x,y coordinates
    theta_inc = 2*math.pi/num_steps
    for i in xrange(len(moon_matrix)):
        theta = theta_inc * i
        moon_matrix[i][0] = MOON_DISTANCE * math.cos(theta)
        moon_matrix[i][1] = MOON_DISTANCE * math.sin(theta)
    #print moon_matrix[:,0]
    return moon_matrix
def plot(mm):
    plt.axis('equal')
    plt.plot(mm[:,0], mm[:,1])
mm = orbit()
plot(mm)
#if __name__ == "__main__":
#%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import math
"""
PROBLEM 1
Modify the orbit function below to model
one revolution of the moon aroudn the eart
assuming orbit is circular.
Use math.cos(angle) and math.sin(angle)
in radians.
"""
MOON_DISTANCE = 386e6 # radius
def orbit():
    num_steps = 50
    moon_matrix = np.zeros([num_steps + 1, 2]) #2 x 51 matrix for x,y coordinates
    theta_inc = 2*math.pi/float(num_steps)
    for i in xrange(len(moon_matrix)):
        theta = theta_inc * i
        moon_matrix[i][0] = MOON_DISTANCE * math.cos(theta)
        moon_matrix[i][1] = MOON_DISTANCE * math.sin(theta)
    #print moon_matrix[:,0]
    return moon_matrix
def plot(mm):
    plt.axis('equal')
    plt.plot(mm[:,0], mm[:,1])
mm = orbit()
plot(mm)
#if __name__ == "__main__":
#%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import math
"""
PROBLEM 1
Modify the orbit function below to model
one revolution of the moon aroudn the eart
assuming orbit is circular.
Use math.cos(angle) and math.sin(angle)
in radians.
"""
MOON_DISTANCE = 386e6 # radius
def orbit():
    num_steps = 50
    moon_matrix = np.zeros([num_steps + 1, 2]) #2 x 51 matrix for x,y coordinates
    theta_inc = 2*math.pi/float(num_steps)
    for i in xrange(len(moon_matrix)):
        theta = theta_inc * i
        moon_matrix[i][0] = MOON_DISTANCE * math.cos(theta)
        moon_matrix[i][1] = MOON_DISTANCE * math.sin(theta)
    #print moon_matrix[:,0]
    return moon_matrix
def plot(mm):
    plt.axis('equal')
    plt.plot(mm[:,0], mm[:,1])
    plt.show()
mm = orbit()
plot(mm)
#if __name__ == "__main__":
#%matplotlib inline
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import math
"""
PROBLEM 1
Modify the orbit function below to model
one revolution of the moon aroudn the eart
assuming orbit is circular.
Use math.cos(angle) and math.sin(angle)
in radians.
"""
MOON_DISTANCE = 386e6 # radius
def orbit():
    num_steps = 50
    moon_matrix = np.zeros([num_steps + 1, 2]) #2 x 51 matrix for x,y coordinates
    theta_inc = 2*math.pi/float(num_steps)
    for i in xrange(len(moon_matrix)):
        theta = theta_inc * i
        moon_matrix[i][0] = MOON_DISTANCE * math.cos(theta)
        moon_matrix[i][1] = MOON_DISTANCE * math.sin(theta)
    #print moon_matrix[:,0]
    return moon_matrix
def plot(mm):
    plt.axis('equal')
    plt.plot(mm[:,0], mm[:,1])
    plt.show()
if __name__ == "__main__":
    mm = orbit()
    plot(mm)
for angle in angles:
            pass
            plt.plot(x[:,0],x[:,1])
"""
SPACE & TIME
REF: http://nbviewer.jupyter.org/github/numerical-mooc/numerical-mooc/blob/master/lessons/02_spacetime/02_01_1DConvection.ipynb
1D LINEAR EQUATION
    - Represents wave propogating with speed c in the x direction.
    = pDu/pdt + c * pDu/pdx = 0
    = This is linear b/c y and y derivatives have no power, products
    applied - they are only linear.
"""
#%matplotlib inline
import numpy
from matplotlib import pyplot
from matplotlib import rcParams
rcParams['font.family'] = 'serif'
rcParams['font.size'] = 16
"""
DISCRETIZING MODEL
    - there are three finite-difference approximations at xi
    - forward difference
        - lim x->0 (u(x + dx) = u(x)) / dx
    - backward difference
        - lim x->0 (u(x) - u(x - dx)) / dx
    - central difference
        - lim x->0 (u(x + dx) - u(x - dx)) / 2dx
    - For the wave eqn, using forward for time, backward for space:
        - pDu/pdt + c * pDu/pdx = 0
        = (u(t + dt) - u(t))/dt + c * (u(x) - u(x - dx))/dx
"""
def initial_square_wave():
    """
    Solve the 1D linear convection equation with a square
    wave initial condition.
    u(x,0) = 2 where 0.5 <= x <= 1.
             1 everywhere else in (0,2)
    """
    nx = 41         # number of spatial grid points/steps
    nt = 25         # number of time grid points/steps
    dx = 2/(nx-1)   # space step
    dt = .02        # time step
    c = 1.          # wave constant (speed)
    # ndarray: N dimensional array
    x = numpy.linspace(0,2,nx) # evenly spaced numbers over a specificed interval in a ndarray
    u = numpy.ones(nx) # ndarray of ones
    lbound = numpy.where(x >= 0.5) # ndarray slice of indices that doesn't meet the condition
    ubound = numpy.where(x <= 1)
    bounds = numpy.intersect1d(lbound, ubound) # find intersection set
    pyplot.plot(x, u, ls='--', lw=3)
    pyplot.ylim(0, 2.5)
    
if __name__ == "__main__":
    initial_square_wave()
print 'hello world"
dir
ls
cd ~
dir
ls
cd Documents
ls
cd ~
ls
ls | less
ls | more
cd ..
ls
cd user
ls
cd master
cd ..
ls
cd saeran
ls
cd master
ls
cd git
python
ipython
ipy
?
%quickref
q
dir
ls
cd Fermi
ls
vim README.md
vim "README.md"
!dir
!ping www.bbc.co.uk
pip install ipython
!vim "README.md"
vim "README.md
!pip install ipython
!python -m pip install --upgrade pip
!ipython
ls
ip google.com
ping www.google.com | clip
!ping www.google.com | clip
print 'hello world'
%save socket_session
%save socket_session 10-20 23
%save socket_session 1-4
print
print "hello"
1/2
import numpy
import pandas as pd
pd.DataFrame(range(1,10),columns=["h"],rows=range(1,10))
print dir(pd.DataFrame)
pd.DataFrame(range(1,10),columns=["h"],labels=range(2,11))
pd.DataFrame(range(1,10),columns=["h"],label=range(2,11))
pd.DataFrame(range(1,10),columns=["h"],index=range(2,11))
reset
cls
clear
clc
cls
ls
cd ..
ls
jupyter notebook --help-all
ipython notebook --help-all
ipython
help
%help
%?
-h
dir
ipython profile create
cd c:\
    master
ls
print "hello world"
import date from datetime
import datetime
print datetime.date
datetime.date.day
datetime.date.day()
datetime.date()
dir(datetime.date)
dir(datetime.date.day)
print datetime.date.day
print datetime.datetime.now()
s = datetime.datetime.now()
s.split(" ")[0]
print type(s)
str(s).split(" ")[0]
s = str(s).split(" ")[0]
%save bash_hx_180422 1-17
%load bash_hx_180422
# %load bash_hx_180422
print "hello world"
import date from datetime
import datetime
print datetime.date
datetime.date.day
datetime.date.day()
datetime.date()
dir(datetime.date)
dir(datetime.date.day)
print datetime.date.day
print datetime.datetime.now()
s = datetime.datetime.now()
s.split(" ")[0]
print type(s)
str(s).split(" ")[0]
s = str(s).split(" ")[0]
get_ipython().magic(u'save bash_hx_180422 1-17')
print s
%load bash_hx_180422
# %load bash_hx_180422
print "hello world"
import date from datetime
import datetime
print datetime.date
datetime.date.day
datetime.date.day()
datetime.date()
dir(datetime.date)
dir(datetime.date.day)
print datetime.date.day
print datetime.datetime.now()
s = datetime.datetime.now()
s.split(" ")[0]
print type(s)
str(s).split(" ")[0]
s = str(s).split(" ")[0]
get_ipython().magic(u'save bash_hx_180422 1-17')
print doc
import readline
print 'hello test'
import datetime
print datetime.datetime.now
print datetime.datetime.now()
readline.write_history_file()
%save save_pyhistory
%save save_pyhistory 1-9
import readline
readline.write_history_file("readline_save")
